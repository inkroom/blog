---
title: mysql事务冲突
date: 2020-05-13 16:38:20
tags: [mysql, 后端, 数据库]
---

开启了事务的情况下mysql如何处理插入

<!-- more -->


## 背景

有两个事务，流程为先查询后添加；关键字段有唯一约束


当事务A开始执行，添加了一条数据，但是尚未提交。

此时事务B进入，查询数据不存在，然后添加一条事务A添加的数据。

---

那么问题是，如果事务A未提交，事务B提交，事务B是否会抛违背唯一约束，具体是在什么时候抛出来的。

## 事实

以下是项目中相关操作的时间：

> A事务开始时间  2020-04-29 14:05:03:881 
> 第一次查询     2020-04-29 14:05:03.888
> 第一次用户添加 2020-04-29 14:05:03.986
> B事务开始时间  2020-04-29 14:05:03.925 
> 第二次查询     2020-04-29 14:05:03.928
> 第二次事务添加 2020-04-29 14:05:04.031
> A事务结束时间  2020-04-29 14:05:05.616
> 异常时间       2020-04-29 14:05:05.620
> B事务结束时间  2020-04-29 14:05:05.627


期间两次查询结果均为空

---

可以看出，两次事务的添加操作执行了类似串行化的逻辑，第二次添加应该是阻塞了，待事务A提交后，第二次添加就立刻抛出了异常。


为了验证以上推测，开启实验

## 验证

开启两个mysql 会话，模拟上述步骤。
| 事务A| 事务B|
| ------------- | ---------------------------------------- |
| start transaction |   | 
| select id from user where phone ='123'  |   | 
| insert into user (id,phone) values (90,'123') |   | 
|  | start transaction | 
|  | insert into user (id,phone) values (91,'123') | 
| commit |  | 
| | uniqe key error |

![transaction](https://user-images.githubusercontent.com/27911304/80572909-a5ec9f80-8a31-11ea-9904-2cd2b2219e4b.gif)

## 原理

在事务A中，通过**insert**语句，给phone=123这一行添加了行锁，事务B同样操作这一行，就会出现阻塞。事务A提交之后，锁就被释放，事务B就能获取到锁

