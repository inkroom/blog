---
title: 偏向锁和轻量级锁
date: 2021-06-03 11:31:14
tags: [java, 锁, 并发]
---

关于java的偏向锁和轻量级锁

<!-- more -->

### 基础知识

java中锁有四种级别，分别是

- 无锁
- 偏向锁
- 轻量级锁
- 重量级锁

其中 **偏向锁** 是锁仅获取一次，后续加锁只需要判断对象头里记录的线程是不是当前线程，如果是就直接进入同步。这样可以免去频繁的加锁

而如果有别的线程来竞争这个锁，那么这个锁就会升级成轻量级锁，线程通过自旋去竞争锁。

锁升级过程是**不可逆**的


### 测试用例

以下为一个两个线程竞争锁的程序

```java

    private static Object sync = new Object();

    public static void main(String[] args) {

        // 测试偏向锁升级成轻量级锁
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    long l = System.nanoTime();
                    //如果没有线程竞争锁，这里就是偏向锁，有竞争升级成轻量级锁，自旋以获取锁，理论上获取锁的时间会更长
                    synchronized (sync) {
                        System.out.printf("%s获取了锁 %d %n", Thread.currentThread().getName(), System.nanoTime() - l);
                        try {
                            TimeUnit.SECONDS.sleep(1);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }

                }
            }
        }).start();


        try {
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    long l = System.nanoTime();
                    //如果没有线程竞争锁，这里就是偏向锁，有竞争升级成轻量级锁，自旋以获取锁，理论上获取锁的时间会更长
                    synchronized (sync) {
                        System.out.printf("后面的%s获取了锁 %d %n", Thread.currentThread().getName(), System.nanoTime() - l);
                        try {
                            TimeUnit.SECONDS.sleep(1);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }

                }
            }
        }).start();
    }
```



输出如下：

> Thread-0获取了锁 42069 
> Thread-0获取了锁 11818 
> Thread-0获取了锁 11702 
> Thread-0获取了锁 11687 
> Thread-0获取了锁 13672 
> Thread-0获取了锁 13185 
> Thread-0获取了锁 13595 
> Thread-0获取了锁 17157 
> Thread-0获取了锁 13052 
> Thread-0获取了锁 21557 
> Thread-0获取了锁 10561 
> Thread-0获取了锁 12408 
> Thread-0获取了锁 16721 
> Thread-0获取了锁 11558 
> Thread-0获取了锁 11267 
> Thread-0获取了锁 15075 
> Thread-0获取了锁 14944 
> 后面的Thread-1获取了锁 12085707971 
> 后面的Thread-1获取了锁 12417 
> 后面的Thread-1获取了锁 14735 
> 后面的Thread-1获取了锁 11964 
> 后面的Thread-1获取了锁 15172 
> Thread-0获取了锁 5010773312 
> Thread-0获取了锁 13285 
> Thread-0获取了锁 13546 
> Thread-0获取了锁 41837 
> Thread-0获取了锁 15667 
> Thread-0获取了锁 17152 
> Thread-0获取了锁 11363 
> Thread-0获取了锁 13901 
> Thread-0获取了锁 13389 
> Thread-0获取了锁 11040 
> Thread-0获取了锁 13411 
> Thread-0获取了锁 75532 
> Thread-0获取了锁 14245 
> Thread-0获取了锁 12482 
> Thread-0获取了锁 16455 
> Thread-0获取了锁 15818 
> Thread-0获取了锁 12914 
> Thread-0获取了锁 10374 
> 后面的Thread-1获取了锁 18052560886 
> 后面的Thread-1获取了锁 14563 
> 后面的Thread-1获取了锁 14105 
> 后面的Thread-1获取了锁 12807 
> Thread-0获取了锁 4007292232 
> Thread-0获取了锁 15244 


后面的获取时间甚至已经到了秒级了，应该已经成了重量级锁，jconsole看到的状态是blocked。这是一个猜想，仅供参考。

---

对程序做修改，去掉第二个线程，改成在main进程中获取一次锁

测试结果如下：

> Thread-0获取了锁 36649
> Thread-0获取了锁 12477
> Thread-0获取了锁 14164
> Thread-0获取了锁 55111
> Thread-0获取了锁 14785
> Thread-0获取了锁 12841
> 只竞争一次的main获取了锁 1069174831
> Thread-0获取了锁 752881
> Thread-0获取了锁 14039
> Thread-0获取了锁 25057
> Thread-0获取了锁 41591
> Thread-0获取了锁 18373
> Thread-0获取了锁 11440
> Thread-0获取了锁 14498
> Thread-0获取了锁 12265

主进程获取耗时1秒，但是Thread0重新获取锁的过程并没有多长，仅第一次高出了一个数量级，多次测试之后均体现了相同的趋势，基本可以排除java获取纳秒的误差

### 流程

借助网上的一篇[博客](https://www.cnblogs.com/tiancai/p/9382542.html)，来梳理一下过程


1、主线程来竞争锁
2、判断锁为偏向锁，且指向的线程0依旧存货
3、暂停线程0
4、将锁升级为轻量级锁
5、继续执行线程0
6、主线程开始自旋
7、主线程执行
8、主线程释放锁
9、线程0获取锁，此时应该为轻量级锁


### 验证

但是以上只是一个猜想，还需要进行验证才行，此处借用**jol**包来获取对象在内存里的结构，可以直接看出是哪种锁

maven依赖

```xml
 <!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core -->
<dependency>
    <groupId>org.openjdk.jol</groupId>
    <artifactId>jol-core</artifactId>
    <version>0.16</version>
<!--<scope>provided</scope>-->
</dependency>
```

用法如下
```java
VirtualMachine vm = VM.current();
System.out.println(vm.getLong(new Object(),0) & 7);//获取对象的markword,就是头8个字节，再 & 7 代表只要低3位
```

输出5


这里解释起来比较复杂，还需要借助另外一张图


![java对象头结构](https://i.loli.net/2021/06/03/mPc21TQCZybaLDS.png)
![无锁和偏向锁](https://i.loli.net/2021/06/03/xuUvdZXnoDOfgCQ.png)

这是**64位**里的结构，32位没有用，不作讨论

5转换完后低位就是**101**，注意，是低位，前面是0省略

根据资料显示，这是一个偏向锁，但是对应的高位又都是0，没有对应的线程id，这就不太对了。

我的资料图是一本书里来的，书都是基于jdk7编写的，我的版本是jdk11，会不会是版本迭代出现变化了？


查阅jdk源码（markOop.hpp，从jdk6到jdk11，这部分都没有改动），关于**markWord**部分注释如下:

```c++

//  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)

//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)

//  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)

//  size:64 ----------------------------------------------------->| (CMS free block)

//

//  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)

//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)

//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)

//  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)

//

//  - hash contains the identity hash value: largest value is

//    31 bits, see os::random().  Also, 64-bit vm's require

//    a hash value no bigger than 32 bits because they will not

//    properly generate a mask larger than that: see library_call.cpp

//    and c1_CodePatterns_sparc.cpp.

//

//  - the biased lock pattern is used to bias a lock toward a given

//    thread. When this pattern is set in the low three bits, the lock

//    is either biased toward a given thread or "anonymously" biased,

//    indicating that it is possible for it to be biased. When the

//    lock is biased toward a given thread, locking and unlocking can

//    be performed by that thread without using atomic operations.

//    When a lock's bias is revoked, it reverts back to the normal

//    locking scheme described below.

//

//    Note that we are overloading the meaning of the "unlocked" state

//    of the header. Because we steal a bit from the age we can

//    guarantee that the bias pattern will never be seen for a truly

//    unlocked object.

//

//    Note also that the biased state contains the age bits normally

//    contained in the object header. Large increases in scavenge

//    times were seen when these bits were absent and an arbitrary age

//    assigned to all biased objects, because they tended to consume a

//    significant fraction of the eden semispaces and were not

//    promoted promptly, causing an increase in the amount of copying

//    performed. The runtime system aligns all JavaThread* pointers to

//    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))

//    to make room for the age bits & the epoch bits (used in support of

//    biased locking), and for the CMS "freeness" bit in the 64bVM (+COOPs).

//

//    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread

//    [0           | epoch | age | 1 | 01]       lock is anonymously biased

//

//  - the two lock bits are used to describe three states: locked/unlocked and monitor.

//

//    [ptr             | 00]  locked             ptr points to real header on stack

//    [header      | 0 | 01]  unlocked           regular object header

//    [ptr             | 10]  monitor            inflated lock (header is wapped out)

//    [ptr             | 11]  marked             used by markSweep to mark an object

//                                               not valid at any other time
```

另外还有**jol**中的代码：

```java
private static String parseMarkWord(long mark) {
    //  64 bits:
    //  unused:25 hash:31 -->| unused_gap:1   age:4    biased_lock:1 lock:2 (normal object)
    //  JavaThread*:54 epoch:2 unused_gap:1   age:4    biased_lock:1 lock:2 (biased object)
    long bits = mark & 0b11;
    switch ((int) bits) {
        case 0b11:
            return "(marked: " + toHex(mark) + ")";
        case 0b00:
            return "(thin lock: " + toHex(mark) + ")";
        case 0b10:
            return "(fat lock: " + toHex(mark) + ")";
        case 0b01:
            String s = "; age: " + ((mark >> 3) & 0xF);
            int tribits = (int) (mark & 0b111);
            switch (tribits) {
                case 0b001:
                    int hash = (int)(mark >>> 8);
                    if (hash != 0) {
                        return "(hash: " + toHex(hash) + s + ")";
                    } else {
                        return "(non-biasable" + s + ")";
                    }
                case 0b101:
                    long thread = mark >>> 10;
                    if (thread == 0) {
                        return "(biasable" + s + ")";
                    } else {
                        return "(biased: " + toHex(thread) + "; epoch: " + ((mark >> 8) & 0x2) + s + ")";
                    }
            }
        default:
            return "(parse error)";
    }
}
```

关于偏向锁部分，重点在于倒数第三位的**baised_lock**。
虽然名字叫偏向锁标记，但是我看下来结果更像是**baiseable_lock**是否可以偏向的标志；如果是1，代表这个对象可以拥有偏向锁；区分是否已经获取了偏向锁，则靠高54位是否为0，获取了偏向锁的情况下，这54bit应该是对应的threadId。

在使用了 **-XX:-UseBiasedLocking** 关闭偏向锁后，这一位就都变成0了。

---

修改代码后重新执行之后的结果如下

![](https://i.loli.net/2021/06/04/vcNsABd2g7Vbykh.png)


可以看出，至少锁确实是发生了变化的。

由原本的偏向锁直接升级成重量级锁

理论上中间应该是经过了轻量级锁的，只是在轻量级锁自旋过多拿不到锁，就升级成重量级了。







